#help_index "Graphics/Misc"
asm {
//************************************
_DC_BLOT_COLOR4::
				PUSH		RBP
				MOV 		RBP, RSP
				PUSH		RSI
				PUSH		RDI
				PUSH		R10

				MOV 		RDI, U64 SF_ARG1[RBP]
				MOV 		RSI, U64 SF_ARG2[RBP]
				MOV 		RBX, U64 SF_ARG3[RBP]
				MOV 		RCX, U64 SF_ARG4[RBP]

				MOV 		R8,  RDI
				ADD 		R8,  RCX
				MOV 		R9,  R8
				ADD 		R9,  RCX
				MOV 		R10, R9
				ADD 		R10, RCX

@@5:		LODSQ
				MOV 		RDX, U64 [RBX]
				CMP 		RAX, RDX
				JE			I32 @@10
				MOV 		U64 [RBX], RAX

				XOR 		RDX, RDX
				BT			RAX, 7 * 8 + 0
				ADC 		RDX, 0
				SHL1		RDX
				BT			RAX, 6 * 8 + 0
				ADC 		RDX, 0
				SHL1		RDX
				BT			RAX, 5 * 8 + 0
				ADC 		RDX, 0
				SHL1		RDX
				BT			RAX, 4 * 8 + 0
				ADC 		RDX, 0
				SHL1		RDX
				BT			RAX, 3 * 8 + 0
				ADC 		RDX, 0
				SHL1		RDX
				BT			RAX, 2 * 8 + 0
				ADC 		RDX, 0
				SHL1		RDX
				BT			RAX, 1 * 8 + 0
				ADC 		RDX, 0
				SHL1		RDX
				BT			RAX, 0 * 8 + 0
				ADC 		RDX, 0
				MOV 		U8 [RDI], DL

				XOR 		RDX, RDX
				BT			RAX, 7 * 8 + 1
				ADC 		RDX, 0
				SHL1		RDX
				BT			RAX, 6 * 8 + 1
				ADC 		RDX, 0
				SHL1		RDX
				BT			RAX, 5 * 8 + 1
				ADC 		RDX, 0
				SHL1		RDX
				BT			RAX, 4 * 8 + 1
				ADC 		RDX, 0
				SHL1		RDX
				BT			RAX, 3 * 8 + 1
				ADC 		RDX, 0
				SHL1		RDX
				BT			RAX, 2 * 8 + 1
				ADC 		RDX, 0
				SHL1		RDX
				BT			RAX, 1 * 8 + 1
				ADC 		RDX, 0
				SHL1		RDX
				BT			RAX, 0 * 8 + 1
				ADC 		RDX, 0
				MOV 		U8 [R8], DL

				XOR 		RDX, RDX
				BT			RAX, 7 * 8 + 2
				ADC 		RDX, 0
				SHL1		RDX
				BT			RAX, 6 * 8 + 2
				ADC 		RDX, 0
				SHL1		RDX
				BT			RAX, 5 * 8 + 2
				ADC 		RDX, 0
				SHL1		RDX
				BT			RAX, 4 * 8 + 2
				ADC 		RDX, 0
				SHL1		RDX
				BT			RAX, 3 * 8 + 2
				ADC 		RDX, 0
				SHL1		RDX
				BT			RAX, 2 * 8 + 2
				ADC 		RDX, 0
				SHL1		RDX
				BT			RAX, 1 * 8 + 2
				ADC 		RDX, 0
				SHL1		RDX
				BT			RAX, 0 * 8 + 2
				ADC 		RDX, 0
				MOV 		U8 [R9], DL

				XOR 		RDX, RDX
				BT			RAX, 7 * 8 + 3
				ADC 		RDX, 0
				SHL1		RDX
				BT			RAX, 6 * 8 + 3
				ADC 		RDX, 0
				SHL1		RDX
				BT			RAX, 5 * 8 + 3
				ADC 		RDX, 0
				SHL1		RDX
				BT			RAX, 4 * 8 + 3
				ADC 		RDX, 0
				SHL1		RDX
				BT			RAX, 3 * 8 + 3
				ADC 		RDX, 0
				SHL1		RDX
				BT			RAX, 2 * 8 + 3
				ADC 		RDX, 0
				SHL1		RDX
				BT			RAX, 1 * 8 + 3
				ADC 		RDX, 0
				SHL1		RDX
				BT			RAX, 0 * 8 + 3
				ADC 		RDX, 0
				MOV 		U8 [R10], DL

@@10:			ADD 		RBX, 8

				INC 		RDI
				INC 		R8
				INC 		R9
				INC 		R10

				DEC 		RCX
				JNZ 		I32 @@5

				POP 		R10
				POP 		RDI
				POP 		RSI
				POP 		RBP
				RET1		32
}

U0 GrRopEquU8NoClipping(I64 ch, U8 reg *dst, I64 width_internal)
{ // render the Font to the Display contexts frame buffer
	U8 *fontPointer = text.font(U8*) + ((ch & &0xFF) * FONT_HEIGHT),
		reg fgColor = ch.u8[1]; 
	U64 ix = FONT_WIDTH -1, i = 0, colInc = width_internal - FONT_WIDTH;

	for (; i < FONT_WIDTH * FONT_HEIGHT; i++) {
		if (Bt(fontPointer, i)) {
			*dst = fgColor;
		}
		dst++;

		if (i & ix == ix) {
			dst += colInc;
		}
	}

	if (ch & ATTRF_UNDERLINE && DISPLAY_UNDERLINE) {
		dst -= width_internal;
		for (i = 0; i < FONT_WIDTH; i++, dst++) {
			*dst = fgColor;
		}
	}

}

Bool IsPixCovered0(CTask *task, I64 x, I64 y)//No clipping
{// No Clipping
	U64 offset = (y / FONT_HEIGHT) * TEXT_COLS + (x / FONT_WIDTH);

	// is this the task drawing this char
	return gr.win_z_buf[offset] == (task->win_z_num -1);
}

_extern			_DC_BLOT_COLOR4				U0	 DCBlotColor4(U8 *dst, I64 *img, I64 *img_cache, I64 count);
